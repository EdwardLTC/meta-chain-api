import { EthService } from './eth.service';
import { Contract, InterfaceAbi } from 'ethers';
import { EnvironmentService } from '../environment/environment.service';
export declare class ContractsService {
    private eth;
    private environmentService;
    private deployments;
    constructor(eth: EthService, environmentService: EnvironmentService);
    getAbi(name: string): InterfaceAbi | null;
    getProvider(): {
        send(method: string, params: Array<any>): Promise<any>;
        "__#private@#private": any;
        _getConnection(): import("ethers").FetchRequest;
        _send(payload: import("ethers").JsonRpcPayload | Array<import("ethers").JsonRpcPayload>): Promise<Array<import("ethers").JsonRpcResult>>;
        "__#private@#private": any;
        _getSubscriber(sub: import("ethers").Subscription): import("ethers").Subscriber;
        get pollingInterval(): number;
        set pollingInterval(value: number);
        "__#private@#private": any;
        _getOption<K extends keyof import("ethers").JsonRpcApiProviderOptions>(key: K): import("ethers").JsonRpcApiProviderOptions[K];
        get _network(): import("ethers").Network;
        _perform(req: import("ethers").PerformActionRequest): Promise<any>;
        _detectNetwork(): Promise<import("ethers").Network>;
        _start(): void;
        _waitUntilReady(): Promise<void>;
        get ready(): boolean;
        getRpcTransaction(tx: import("ethers").TransactionRequest): import("ethers").JsonRpcTransactionRequest;
        getRpcRequest(req: import("ethers").PerformActionRequest): null | {
            method: string;
            args: Array<any>;
        };
        getRpcError(payload: import("ethers").JsonRpcPayload, _error: import("ethers").JsonRpcError): Error;
        getSigner(address?: number | string): Promise<import("ethers").JsonRpcSigner>;
        listAccounts(): Promise<Array<import("ethers").JsonRpcSigner>>;
        destroy(): void;
        "__#private@#private": any;
        get provider(): any;
        get plugins(): Array<import("ethers").AbstractProviderPlugin>;
        attachPlugin(plugin: import("ethers").AbstractProviderPlugin): any;
        getPlugin<T extends import("ethers").AbstractProviderPlugin = import("ethers").AbstractProviderPlugin>(name: string): null | T;
        get disableCcipRead(): boolean;
        set disableCcipRead(value: boolean);
        ccipReadFetch(tx: import("ethers").PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string>;
        _wrapBlock(value: import("ethers").BlockParams, network: import("ethers").Network): import("ethers").Block;
        _wrapLog(value: import("ethers").LogParams, network: import("ethers").Network): import("ethers").Log;
        _wrapTransactionReceipt(value: import("ethers").TransactionReceiptParams, network: import("ethers").Network): import("ethers").TransactionReceipt;
        _wrapTransactionResponse(tx: import("ethers").TransactionResponseParams, network: import("ethers").Network): import("ethers").TransactionResponse;
        getBlockNumber(): Promise<number>;
        _getAddress(address: import("ethers").AddressLike): string | Promise<string>;
        _getBlockTag(blockTag?: import("ethers").BlockTag): string | Promise<string>;
        _getFilter(filter: import("ethers").Filter | import("ethers").FilterByBlockHash): import("ethers").PerformActionFilter | Promise<import("ethers").PerformActionFilter>;
        _getTransactionRequest(_request: import("ethers").TransactionRequest): import("ethers").PerformActionTransaction | Promise<import("ethers").PerformActionTransaction>;
        getNetwork(): Promise<import("ethers").Network>;
        getFeeData(): Promise<import("ethers").FeeData>;
        estimateGas(_tx: import("ethers").TransactionRequest): Promise<bigint>;
        call(_tx: import("ethers").TransactionRequest): Promise<string>;
        getBalance(address: import("ethers").AddressLike, blockTag?: import("ethers").BlockTag): Promise<bigint>;
        getTransactionCount(address: import("ethers").AddressLike, blockTag?: import("ethers").BlockTag): Promise<number>;
        getCode(address: import("ethers").AddressLike, blockTag?: import("ethers").BlockTag): Promise<string>;
        getStorage(address: import("ethers").AddressLike, _position: import("ethers").BigNumberish, blockTag?: import("ethers").BlockTag): Promise<string>;
        broadcastTransaction(signedTx: string): Promise<import("ethers").TransactionResponse>;
        getBlock(block: import("ethers").BlockTag | string, prefetchTxs?: boolean): Promise<null | import("ethers").Block>;
        getTransaction(hash: string): Promise<null | import("ethers").TransactionResponse>;
        getTransactionReceipt(hash: string): Promise<null | import("ethers").TransactionReceipt>;
        getTransactionResult(hash: string): Promise<null | string>;
        getLogs(_filter: import("ethers").Filter | import("ethers").FilterByBlockHash): Promise<Array<import("ethers").Log>>;
        _getProvider(chainId: number): import("ethers").AbstractProvider;
        getResolver(name: string): Promise<null | import("ethers").EnsResolver>;
        getAvatar(name: string): Promise<null | string>;
        resolveName(name: string): Promise<null | string>;
        lookupAddress(address: string): Promise<null | string>;
        waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | import("ethers").TransactionReceipt>;
        waitForBlock(blockTag?: import("ethers").BlockTag): Promise<import("ethers").Block>;
        _clearTimeout(timerId: number): void;
        _setTimeout(_func: () => void, timeout?: number): number;
        _forEachSubscriber(func: (s: import("ethers").Subscriber) => void): void;
        _recoverSubscriber(oldSub: import("ethers").Subscriber, newSub: import("ethers").Subscriber): void;
        on(event: import("ethers").ProviderEvent, listener: import("ethers").Listener): Promise<any>;
        once(event: import("ethers").ProviderEvent, listener: import("ethers").Listener): Promise<any>;
        emit(event: import("ethers").ProviderEvent, ...args: Array<any>): Promise<boolean>;
        listenerCount(event?: import("ethers").ProviderEvent): Promise<number>;
        listeners(event?: import("ethers").ProviderEvent): Promise<Array<import("ethers").Listener>>;
        off(event: import("ethers").ProviderEvent, listener?: import("ethers").Listener): Promise<any>;
        removeAllListeners(event?: import("ethers").ProviderEvent): Promise<any>;
        addListener(event: import("ethers").ProviderEvent, listener: import("ethers").Listener): Promise<any>;
        removeListener(event: import("ethers").ProviderEvent, listener: import("ethers").Listener): Promise<any>;
        get destroyed(): boolean;
        get paused(): boolean;
        set paused(pause: boolean);
        pause(dropWhilePaused?: boolean): void;
        resume(): void;
    };
    loadDeployments(): void;
    getContract(name: string): Contract;
    getContractWs(name: string): Contract;
}
